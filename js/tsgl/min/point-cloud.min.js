'use strict';const DEGREE_TO_RADIAN_FACTOR=Math.PI/180,SLOPE_SHIFT=-127.5;
class PointCloud{constructor(a,c,e,d,b,f,g={azimuthal:0,polar:0},h=new Uint8Array(Array(c*e*4).fill(255))){this.normalMap=a;this.depthFactor=d;this.width=c;this.height=e;this.maxVertexCount=b;this.azimuthalAngles=f;this.rotation=g;this.mask=h;this.calculateIndexMaps()}getWidth(){return this.width}getHeight(){return this.height}getAzimuthalAngles(){return this.azimuthalAngles}downloadObj(a,c){c&&(c.style.display="none");const e=this;setTimeout(()=>{a+=".obj";let d=document.createElement("a");d.style.display=
"none";let b=new Blob([e.getObjString()],{type:"text/plain; charset = utf-8"}),f=window.URL.createObjectURL(b);d.setAttribute("href",window.URL.createObjectURL(b));d.setAttribute("download",a);document.body.appendChild(d);d.click();window.URL.revokeObjectURL(f);d.remove();c&&setTimeout(()=>{c.style.display="inherit"},500)})}getRotatedVertex(a){const c=(d,b)=>{let f=0;for(let g=0;3>g;g++)f+=d[g]*b[g];return f},e=(d,b,f)=>{var g=f*DEGREE_TO_RADIAN_FACTOR;f=Math.sqrt(c(b,b));b=[b[0]/f,b[1]/f,b[2]/f];
var h=Math.cos(g/2),k=-b[0]*Math.sin(g/2);f=-b[1]*Math.sin(g/2);const l=-b[2]*Math.sin(g/2);b=h*h;g=k*k;const m=f*f,n=l*l,p=k*f,q=h*l,r=h*f;h*=k;k*=l;f*=l;f=[[b+g-m-n,2*(p+q),2*(k-r)],[2*(p-q),b+m-g-n,2*(f+h)],[2*(k+r),2*(f-h),b+n-g-m]];return[c(d,f[0]),c(d,f[1]),c(d,f[2])]};return e(e(a,[0,0,1],this.rotation.azimuthal),[0,1,0],this.rotation.polar)}getVertexIndex(a){return this.pixelToVertexIndexMap[a]}calculateIndexMaps(){this.pixelToVertexIndexMap=Array(this.width*this.height);this.vertexToPixelIndexMap=
[];let a=0;for(let c=0;c<this.height;c++)for(let e=0;e<this.width;e++){const d=e+c*this.width;this.isPixelMaskedOut(d)?this.pixelToVertexIndexMap[d]=null:(this.pixelToVertexIndexMap[d]=a,this.vertexToPixelIndexMap.push(d),a++)}}getEdgeFramePixels(){if(void 0===this.edgeFramePixels){this.edgeFramePixels=[];var a=this.height;const c=this.width;for(let e=0;e<this.width;e++)this.edgeFramePixels.push({x:e,y:-1}),this.edgeFramePixels.push({x:e,y:a});for(a=0;a<this.height;a++)this.edgeFramePixels.push({x:-1,
y:a}),this.edgeFramePixels.push({x:c,y:a})}return this.edgeFramePixels}isInDimensions(a){return a.x<this.width&&a.y<this.height&&0<=a.x&&0<=a.y}getPixelLine(a,c,e){const d=[];var b=a.x,f=a.y;a={x:a.x,y:a.y};do{do{b+=c.x;f+=c.y;var g=Math.round(b);var h=Math.round(f)}while(g===a.x&&h===a.y);a.x=g;a.y=h;if(g=this.isInDimensions(a))h=this.getPixelSlope(a,c,e),d.push({x:a.x,y:a.y,slope:h})}while(g);return d}getPixelLinesFromAzimuthalAngle(a,c){const e=[];a=(a+180)*DEGREE_TO_RADIAN_FACTOR;a={x:Math.cos(a),
y:Math.sin(a)};1e-8>a.x&&-1e-8<a.x&&(a.x=0);1e-8>a.y&&-1e-8<a.y&&(a.y=0);for(let b=0;b<this.getEdgeFramePixels().length;b++){var d=this.getEdgeFramePixels()[b];d=this.getPixelLine(d,a,c);1<d.length&&e.push(d)}return e}isPixelMaskedOut(a){a*=4;return 0===this.mask[a+0]+this.mask[a+1]+this.mask[a+2]}getPixelSlope(a,c,e){a=a.x+a.y*this.width;if(this.isPixelMaskedOut(a))return null;a*=4;return c.x*(e[a+0]+SLOPE_SHIFT)+c.y*(e[a+1]+SLOPE_SHIFT)}async getLocalGradientFactor(){let a=new Shader(this.normalMap.getDimensions());
a.bind();var c=this.normalMap.getGlslNormal(),e=new GlslVector3([new GlslFloat(1),new GlslFloat(0),new GlslFloat(0)]);const d=new GlslVector3([new GlslFloat(0),new GlslFloat(1),new GlslFloat(0)]),b=new GlslVector3([new GlslFloat(0),new GlslFloat(0),new GlslFloat(1)]);(new GlslFloat(1)).subtractFloat(c.dot(b));c=new GlslVector3([c.dot(e),c.dot(d),new GlslFloat(0)]);c=GlslRendering.render(c.getVector4());e=c.getPixelArray();LOADING_AREA.appendChild(await c.getJsImage());a.purge();return e}calculateAnisotropicIntegral(a,
c){const e=Array(this.width*this.height);a=this.getPixelLinesFromAzimuthalAngle(a,c);for(c=0;c<a.length;c++){let d=0;for(let b=0;b<a[c].length;b++){const f=a[c][b].x+a[c][b].y*this.width;a[c][b].slope?(e[f]=d,d+=a[c][b].slope*-this.depthFactor):(e[f]=null,d=0)}}return e}summarizeHorizontalImageLine(a,c,e){const d={averageError:0,highestError:0,zErrors:Array(this.width)};for(let f=0;f<this.width;f+=c){var b=f+a*this.width;let g=this.getVertexIndex(b);if(g){g*=3;let h=0,k=0,l=this.integrals.length;
for(let m=0;m<this.integrals.length;m++){const n=this.integrals[m][b];isNaN(n)||(h+=n,0!==m&&(k+=Math.abs(this.integrals[0][b]-n)))}h/=l;k/=l;d.averageError+=k/e;d.highestError=Math.max(d.highestError,k);d.zErrors[f]=k;b=this.getRotatedVertex([f/this.width-.5,a/this.width-.5,h/this.width-.5]);console.log(b);this.gpuVertices[g+0]=b[0];this.gpuVertices[g+1]=b[1];this.gpuVertices[g+2]=b[2];this.objString+="v "+f+" "+a+" "+h+"\n"}}return d}async calculate(){var a=new DOMStatusElement("Calculating slopes."),
c=new DOMStatusElement("Integrating normal mapping."),e=new DOMStatusElement("Summarizing data.");a=new ThreadPool(a);a.add(this.getLocalGradientFactor.bind(this));a=(await a.run())[0];c=new ThreadPool(c);for(let b=0,f=this.azimuthalAngles.length;b<f;b++){var d=this.calculateAnisotropicIntegral.bind(this,this.azimuthalAngles[b],a);c.add(d)}this.integrals=await c.run();this.objString="";a=this.width*this.height;c=Array(this.vertexToPixelIndexMap.length);this.gpuVertices=Array(3*this.vertexToPixelIndexMap.length);
console.log(this.vertexToPixelIndexMap.length);console.log(this.width*this.height);e=new ThreadPool(e);for(d=0;d<this.height;d+=1){const b=this.summarizeHorizontalImageLine.bind(this,d,1,a);e.add(b)}e=await e.run();a=d=0;for(let b=0,f=e.length;b<f;b++)d=Math.max(...e[b].zErrors,d),a+=e[b].averageError;for(let b=0,f=e.length;b<f;b++){d=e[b].zErrors;for(let g=0,h=d.length;g<h;g++)c.push(d[g])}console.log("Average error of z values: "+a,1)}getAnglesZValues(){return this.integrals}getObjString(){return this.objString}getGpuVertices(){return this.gpuVertices}}
;